# Design notes

## Missing files

What happens if a file referenced in a build rule isn't present?

For the purpose of ordering: a build is "ready" when all dependent builds have
been brought up to date, and that is independent of whether the files are
present or not.

A missing output, after a build runs, is allowed. This is used in build files as
a marker for build rules that want to always run.

Finally, all the checking happens when deciding whether a ready build is dirty:

- A missing dirtying input is an error.
- A missing order-only input is an error unless it's a generated file.  (This
  handles the case where there are build rules used for order-only purposes
  that don't write their outputs.)
- A missing discovered input is allowed. (This is the case where you deleted a
  .h but also removed a reference to it from the .c at the same time.)
- A missing output, which otherwise may have been generated by a previous run,
  is allowed.

But if any of those files are missing we call it dirty without bothering to
compute a hash. In this manner we never compute a hash involving any missing
files.

## Parsing

Parsing .ninja files is part of the critical path for n2, because it must
be complete before any other work can be done.  Some properties of the n2
parser that break abstraction to this end:

- There is no separate lexer.  Ninja syntax is not really lexer friendly
  in the first place.
- When possible, `$variable` expansions happen as they're encountered, so
  that we don't need to build up a parsed representation of strings and
  carry around variable environments.
- Parsed entities that deal with paths are generic over a `Path` type, and
  path strings are converted to Paths as they are parsed.  (In practice
  the `Path` type is `graph::FileId`, but the parsing code isn't aware of
  this type directly.)  This (and the previous bullet) allows the parser to
  reuse a single `String` buffer when parsing paths, which is the bulk of what
  the parser does.

## Tracking build state

While building, we have a bunch of `Build` objects that represent individual
build steps that go through a series of states.  To represent these well I
went through a few patterns and eventually came up with a design I'm pretty
happy with.

First, for each `Build` we store its current state.  This lets us quickly answer
questions like "is the build id X ready or not?"  (You could imagine storing
this directly in the `Build` or in a side HashMap from id to state, but that's
an implementation detail.)  We use this for things like tracking whether we've
already visited a given `Build` when doing a traveral of the graph while
loading.  This also has the benefit of ensuring a given `Build` is always in
exactly one known state.

Second, we store data structures on the side for states where we care about
having quicker views onto this state.  The idea here is that depending on the
particular needs of a given state we can model those needs specially.  For
example, we need to be able to grab the next `Ready` build to work on it, so
there's a `VecDeque` holding those, while builds that go into the `Queued` state
queue into separate run pools, and builds that are `Running` are just tracked
with an integer counter on the run pool.
