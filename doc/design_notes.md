# Design notes

## Missing files

What happens if a file referenced in a build rule isn't present?

For the purpose of ordering: a build is "ready" when all dependent builds have
been brought up to date, and that is independent of whether the files are
present or not.

A missing output, after a build runs, is allowed. This is used in build files as
a marker for build rules that want to always run.

Finally, all the checking happens when deciding whether a ready build is dirty:

- A missing dirtying input is an error.
- A missing order-only input is an error unless it's a generated file.  (This
  handles the case where there are build rules used for order-only purposes
  that don't write their outputs.)
- A missing discovered input is allowed. (This is the case where you deleted a
  .h but also removed a reference to it from the .c at the same time.)
- A missing output, which otherwise may have been generated by a previous run,
  is allowed.

But if any of those files are missing we call it dirty without bothering to
compute a hash. In this manner we never compute a hash involving any missing
files.

## Parsing

Parsing .ninja files is part of the critical path for n2, because it must
be complete before any other work can be done.  Some properties of the n2
parser that break abstraction to this end:

- There is no separate lexer.  Ninja syntax is not really lexer friendly
  in the first place.
- When possible, `$variable` expansions happen as they're encountered, so
  that we don't need to build up a parsed representation of strings and
  carry around variable environments.
- Parsed entities that deal with paths are generic over a `Path` type, and
  path strings are converted to Paths as they are parsed.  (In practice
  the `Path` type is `graph::FileId`, but the parsing code isn't aware of
  this type directly.)  This (and the previous bullet) allows the parser to
  reuse a single `String` buffer when parsing paths, which is the bulk of what
  the parser does.
