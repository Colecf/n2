//! Build runner, choosing and executing tasks as determined by out of date inputs.

use crate::db;
use crate::depfile;
use crate::graph::*;
use crate::scanner::Scanner;
use anyhow::{anyhow, bail};
use std::collections::HashSet;
use std::io::Write;

pub struct Work<'a> {
    graph: &'a mut Graph,
    db: &'a mut db::Writer,
    last_state: &'a FileState,
    want: HashSet<BuildId>,
    ready: HashSet<BuildId>,
}

impl<'a> Work<'a> {
    pub fn new(graph: &'a mut Graph, last_state: &'a FileState, db: &'a mut db::Writer) -> Self {
        Work {
            graph: graph,
            want: HashSet::new(),
            ready: HashSet::new(),
            db: db,
            last_state: last_state,
        }
    }

    /// Visits a BuildId that is an input to the desired output.
    /// Will recursively visit its own inputs.
    fn want_build(&mut self, state: &mut FileState, id: BuildId) -> anyhow::Result<()> {
        if self.want.contains(&id) {
            return Ok(());
        }

        let mut inputs_ready = true;
        for id in self.graph.build(id).dirtying_ins().collect::<Vec<_>>() {
            let ready = self.want_file(state, id)?;
            inputs_ready = inputs_ready && ready;
        }
        for id in self.graph.build(id).order_only_ins().to_vec() {
            self.want_file(state, id)?;
            inputs_ready = inputs_ready && state.file(id).is_none();
        }
        self.want.insert(id);
        if inputs_ready {
            self.ready.insert(id);
        }

        Ok(())
    }

    fn update_build(&mut self, state: &mut FileState, id: BuildId) -> anyhow::Result<bool> {
        state.hash(self.graph, id)?;
        if state.hash_changed(self.last_state, id) {
            self.run_one(state, id)?;
        }
        self.build_finished(state, id)?;
        Ok(true)
    }

    /// Visits a FileId that is an input to the desired output.
    /// Will recursively visit its own inputs.
    /// Returns true if the file is not generated by the build.
    pub fn want_file(&mut self, state: &mut FileState, id: FileId) -> anyhow::Result<bool> {
        let file = self.graph.file(id);
        Ok(match file.input {
            None => {
                // Input file not generated by a build.  stat here.
                if state.file(id).is_none() {
                    state.restat(id, &file.name)?;
                }
                true
            }
            Some(bid) => {
                // Enqueue a check of the build state.
                self.want_build(state, bid)?;
                false
            }
        })
    }

    fn recheck_ready(&mut self, state: &FileState, id: BuildId) -> bool {
        let build = self.graph.build(id);
        println!("  recheck {:?} {}", id, build.location);
        for id in build.depend_ins() {
            let file = self.graph.file(id);
            if state.file(id).is_none() {
                println!("    {:?} {} not ready", id, file.name);
                return false;
            }
        }
        println!("    now ready");
        true
    }

    fn read_depfile(&mut self, id: BuildId, path: &str) -> anyhow::Result<bool> {
        let mut bytes = match std::fs::read(path) {
            Ok(b) => b,
            Err(e) => bail!("read {}: {}", path, e),
        };
        bytes.push(0);

        let mut scanner = Scanner::new(unsafe { std::str::from_utf8_unchecked(&bytes) });
        let parsed_deps = depfile::parse(&mut scanner)
            .map_err(|err| anyhow!("in {}: {}", path, scanner.format_parse_error(err)))?;
        // TODO verify deps refers to correct output
        let deps: Vec<FileId> = parsed_deps
            .deps
            .iter()
            .map(|dep| self.graph.file_id(dep))
            .collect();

        let changed = if self.graph.build_mut(id).update_deps(deps) {
            println!("deps changed {:?}", self.graph.build(id).deps_ins());
            true
        } else {
            false
        };
        Ok(changed)
    }

    fn run_one(&mut self, state: &mut FileState, id: BuildId) -> anyhow::Result<()> {
        let build = self.graph.build(id);
        let cmdline = match &build.cmdline {
            None => return Ok(()),
            Some(c) => c,
        };
        println!("$ {}", cmdline);
        let output = std::process::Command::new("sh")
            .arg("-c")
            .arg(cmdline)
            .output()?;
        if !output.stdout.is_empty() {
            std::io::stdout().write_all(&output.stdout)?;
        }
        if !output.stderr.is_empty() {
            std::io::stdout().write_all(&output.stderr)?;
        }
        if !output.status.success() {
            bail!("subcommand failed");
        }
        if let Some(depfile) = &build.depfile {
            let depfile = &depfile.clone();
            self.read_depfile(id, depfile)?;
        }

        // Rust thinks self.read_depfile may have modified build, so reread here.
        let build = self.graph.build(id);

        // We may have discovered new deps, so ensure we have mtimes for those.
        for &id in build.deps_ins() {
            if state.file(id).is_some() {
                // Already have state for this file.
                continue;
            }
            let file = self.graph.file(id);
            if file.input.is_some() {
                panic!("discovered new dep on generated file {}", file.name);
            }
            state.restat(id, &file.name)?;
        }

        let hash = state.hash(self.graph, id)?;
        self.db.write_build(self.graph, id, hash)?;

        Ok(())
    }

    fn build_finished(&mut self, state: &mut FileState, id: BuildId) -> anyhow::Result<()> {
        let build = self.graph.build(id);
        println!("finished {:?} {}", id, build.location);
        let mut ready_builds = HashSet::new();
        for &id in build.outs() {
            for &id in &self.graph.file(id).dependents {
                if !self.want.contains(&id) {
                    continue;
                }
                ready_builds.insert(id);
            }
        }
        for id in ready_builds {
            if !self.recheck_ready(state, id) {
                continue;
            }
            self.ready.insert(id);
        }
        Ok(())
    }

    pub fn run(&mut self, state: &mut FileState) -> anyhow::Result<()> {
        while !self.want.is_empty() {
            let id = match self.ready.iter().next() {
                None => {
                    panic!("no ready, but want {:?}", self.want);
                }
                Some(&id) => id,
            };
            self.want.remove(&id);
            self.ready.remove(&id);
            self.update_build(state, id)?;
        }
        Ok(())
    }
}
